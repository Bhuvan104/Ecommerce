function Validations(validationRules, req, errors) {
    console.log(validationRules)
    console.log(req)
    console.log(errors)
    validationRules.forEach(rule => {
        if (rule.type !== "object") {
            const value = req[rule.field];
            const field = rule.field;

            if (rule.required && (value === undefined || value === null || value === '')) {
                // Initialize errors[field] as an array if it's undefined
                errors[field] = errors[field] || [];
                errors[field].push(`${field} is required`);

            } else {
                if (rule.type === "string") {
                    if (rule.minLength && value.length < rule.minLength) {
                        errors[field] = errors[field] || [];
                        errors[field].push(`${field} must be at least ${rule.minLength} characters`);
                    }
                    if (rule.maxLength && value.length > rule.maxLength) {
                        errors[field] = errors[field] || [];
                        errors[field].push(`${field} must be at most ${rule.maxLength} characters`);
                    }
                    if (rule.firstNamePattern && !rule.firstNamePattern.test(value)) {
                        errors[field] = errors[field] || [];
                        errors[field].push(rule.message || `Invalid ${field}`);
                    }
                    if (rule.lastNamePattern && !rule.lastNamePattern.test(value)) {
                        errors[field] = errors[field] || [];
                        errors[field].push(rule.message || `Invalid ${field}`);
                    }
                }
                if(rule.type="email"){
                    if (rule.emailPattern && !rule.emailPattern.test(value)) {
                        errors[field] = errors[field] || [];
                        errors[field].push(rule.message || `Invalid ${field}`);
                    }
                }
                // Add other validation rules for different field types
            }
        } else {
            // Handle nested object validation
            for (const nestedField in rule) {
                if (nestedField !== 'type') {
                    const nestedValue = req[nestedField];
                    const nestedErrors = {};

                    if (Array.isArray(nestedValue)) {
                        nestedValue.forEach(nestedObj => {
                            Validations(rule[nestedField], nestedObj, nestedErrors);
                        });
                    } else if (nestedValue && typeof nestedValue === 'object') {
                        Validations(rule[nestedField], nestedValue, nestedErrors);
                    }

                    // Merge nested object errors into main errors object with keys corresponding to field names
                    errors[nestedField] = errors[nestedField] || {};
                    Object.assign(errors[nestedField], nestedErrors);
                }
            }
        }
    });

    return errors;
}

module.exports = Validations;
